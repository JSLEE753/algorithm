## 문제 정보

- 플랫폼 : 프로그래머스
- 문제 : https://www.acmicpc.net/problem/1463
- 난이도 : 실버3
- 사용 언어 : python

## 접근 방식

- 연산을 사용하는 최솟값을 구하려면 모든 경로를 탐색해서 가장 최소의 경로를 찾아야 한다고 생각했음

- 따라서 queue에 현재 숫자와, 거리를 의미하는 level을 iterable로 주고, 탐색 수행

- 이 방법은 다른 코드에 비해 소모 시간이 컸음.

## 다른 방식

- `n+1` 만큼의 배열을 생성, 이 배열의 index가 의미하는 것은 숫자를 의미하고 해당 인덱스의 요소가 의미하는 것은 `소요된 최소 횟수`.

- 기본적으로 `이전 숫자 + 1`을 더해서 기본 횟수로 지정, `//2`와 `//3`을 수행했을 때 각각 `이전 숫자 + 1`과 몫에 해당하는 원소의 값 중 최소를 선택하여 최소 연산을 구할 수 있음.
